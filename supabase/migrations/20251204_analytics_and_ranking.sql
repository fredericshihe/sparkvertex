-- Create Analytics Events Table
create table if not exists public.analytics_events (
  id bigint generated by default as identity not null,
  item_id bigint null,
  user_id uuid null,
  client_fingerprint text null,
  action_type text not null,
  created_at timestamp with time zone null default now(),
  constraint analytics_events_pkey primary key (id),
  constraint analytics_events_item_id_fkey foreign KEY (item_id) references items (id) on delete CASCADE,
  constraint analytics_events_user_id_fkey foreign KEY (user_id) references auth.users (id) on delete set null
) TABLESPACE pg_default;

create index IF not exists idx_analytics_events_user on public.analytics_events using btree (user_id) TABLESPACE pg_default;
create index IF not exists idx_analytics_events_fingerprint on public.analytics_events using btree (client_fingerprint) TABLESPACE pg_default;
create index IF not exists idx_analytics_events_check on public.analytics_events using btree (item_id, action_type, created_at) TABLESPACE pg_default;

-- Function: increment_downloads
DROP FUNCTION IF EXISTS increment_downloads(bigint, text);
CREATE OR REPLACE FUNCTION increment_downloads(p_item_id bigint, fingerprint text)
RETURNS void
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public, pg_temp
AS $$
DECLARE
    current_user_id UUID;
    should_count BOOLEAN;
BEGIN
    -- Get current user ID if logged in
    current_user_id := auth.uid();
    
    -- Check if this user/fingerprint has downloaded this item in the last 1 hour
    SELECT NOT EXISTS (
        SELECT 1 FROM analytics_events
        WHERE analytics_events.item_id = p_item_id
        AND action_type = 'download'
        AND created_at > NOW() - INTERVAL '1 hour'
        AND (
            (current_user_id IS NOT NULL AND user_id = current_user_id)
            OR 
            (current_user_id IS NULL AND client_fingerprint = fingerprint)
        )
    ) INTO should_count;

    -- If allowed, update counter and log event
    IF should_count THEN
        -- Log the event
        INSERT INTO analytics_events (item_id, user_id, client_fingerprint, action_type)
        VALUES (p_item_id, current_user_id, fingerprint, 'download');

        -- Update the counter
        UPDATE items
        SET 
            downloads = COALESCE(downloads, 0) + 1
        WHERE id = p_item_id;
    END IF;
END;
$$;
-- Function: increment_views
DROP FUNCTION IF EXISTS increment_views(bigint, text);
CREATE OR REPLACE FUNCTION increment_views(p_item_id bigint, fingerprint text)
RETURNS void
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public, pg_temp
AS $$
DECLARE
    current_user_id UUID;
    should_count BOOLEAN;
BEGIN
    -- Get current user ID if logged in
    current_user_id := auth.uid();
    
    -- Check if this user/fingerprint has viewed this item in the last 1 hour
    SELECT NOT EXISTS (
        SELECT 1 FROM analytics_events
        WHERE analytics_events.item_id = p_item_id
        AND action_type = 'page_view'
        AND created_at > NOW() - INTERVAL '1 hour'
        AND (
            (current_user_id IS NOT NULL AND user_id = current_user_id)
            OR 
            (current_user_id IS NULL AND client_fingerprint = fingerprint)
        )
    ) INTO should_count;

    -- If allowed, update counter and log event
    IF should_count THEN
        -- Log the event
        INSERT INTO analytics_events (item_id, user_id, client_fingerprint, action_type)
        VALUES (p_item_id, current_user_id, fingerprint, 'page_view');

        -- Update the counter
        UPDATE items
        SET page_views = COALESCE(page_views, 0) + 1
        WHERE id = p_item_id;
    END IF;
END;
$$;

-- Function: update_daily_ranks
CREATE OR REPLACE FUNCTION update_daily_ranks()
RETURNS void
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public, pg_temp
AS $$
BEGIN
  WITH ranked_items AS (
    SELECT 
      id,
      RANK() OVER (
        ORDER BY 
          (
            -- 1. AI Quality Score (40% Weight): Intrinsic value (0-40 pts)
            COALESCE(total_score, 0) * 0.4
            
            -- 2. Popularity (Logarithmic): Prevents "Rich get Richer" monopoly
            -- Likes: High value signal (0-20 pts)
            + (CASE WHEN likes > 0 THEN LOG(likes + 1) * 20 ELSE 0 END)
            
            -- Downloads: High value signal (0-20 pts)
            + (CASE WHEN downloads > 0 THEN LOG(downloads + 1) * 20 ELSE 0 END)
            
            -- Page Views: Lower value signal (0-10 pts)
            + (CASE WHEN page_views > 0 THEN LOG(page_views + 1) * 10 ELSE 0 END)
            
            -- 3. Freshness Boost (Decay): Gives new apps a "Honeymoon Phase" (0-30 pts)
            -- Decays to 0 over 60 days. Day 0 = 30pts.
            + (GREATEST(0, 60 - EXTRACT(DAY FROM (NOW() - created_at))) * 0.5)
            
            -- 4. Random Jitter (Shuffle): Gives old/hidden gems a chance to surface (0-10 pts)
            -- Ensures the list isn't static every day
            + (RANDOM() * 10)
          ) DESC
      ) as new_rank
    FROM items
    WHERE is_public = true
  )
  UPDATE items
  SET daily_rank = ranked_items.new_rank
  FROM ranked_items
  WHERE items.id = ranked_items.id;
END;
$$;
